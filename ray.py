"""
Generate rays and ray bundles
"""

import numpy as np


class Ray:
    """Produce the optical rays and output the position and direction
       coordinate when necessary

    Args:
        p -- ray positions in 3D Cartesian stored as a list of np arrays
        k -- ray directions in 3D Cartesian stored as a list of np arrays
    """

    def __init__(self, p=[0, 0, 0], k=[0, 0, 1]):
        if len(p) != 3:
            raise Exception("ray position requires three coordinates")

        if len(k) != 3:
            raise Exception("ray direction requires three coordinates")

        self._p = [np.array(p, dtype=float)]
        self._k = [np.array(k, dtype=float)]

    def p(self):
        """Return current poistion along the ray"""
        return self._p[-1]

    def k(self):
        """Return current direction of the ray"""
        return self._k[-1]

    def append(self, p, k):
        """Append new p or k coordinates to the ray"""
        self._p = np.vstack((self._p, p))
        self._k = np.vstack((self._k, k))
        return self

    def vertices(self):
        """Return all position coordinates along the ray"""
        return self._p

    def directions(self):
        """Return all direction coordinates along the ray"""
        return self._k


class RayBundle:
    """Produce a bundle of rays and plot 2D and 3D graphs for the ray
       propagation

    Args:
        radius -- radius of the ray bundle; the radii of the concentric
                  circles will increase by radius/n successively
        n -- the number of rays will increase by n for successive
             concentric circle of rays in xy-plane
        p_init -- initial p coordinate of the ray bundle centre
        k_init -- inital k direction in 3D Cartesian

    Main parameters:
        n_tot -- total number of rays generated
    """

    def __init__(self, radius=0.5, n=6, p_init=[0, 0, -2], k_init=[0, 0, 1]):
        self._radius = radius
        self._n = n
        self._p_init = p_init
        self._k_init = k_init

        self._n_tot = 0

    def generate_ray_bundle(self):
        """Generate a bundle of rays with their initial position and direction
           coordinate to form a uniform collimated beam

        A list of ray objects are generated to simulate a ray bundle. The
        initial ray position and direction coordiantes are generated in 3D
        cylindrical polar coordinate, i.e. in the form of [rho, phi, z].

        The ray bundle is generated by putting rays on a set of equally-spaced
        concentric circles, and the number of rays per circle increases by n
        for successive circles. Along one circle, the rays are placed per pi/n
        radians to ensure the rays are equidistant.

        Return:
            ray_list -- a list of objects that represent the rays in the ray
                        bundle, and each object contains the initial position
                        and direction for one ray in 3D Cartesian
        """
        # list of rho values for inital ray position in cylindrical polar
        rho_p = np.linspace(0, self._radius, self._n)

        ray_list = []
        n_phi = 1  # number of ray on the smallest concentric circle
        self._n_tot = 0
        for i1 in range(self._n):
            # list of phi values for inital ray position in cylindrical polar
            phi_p = np.linspace(0, 2*np.pi, n_phi)

            if n_phi != 1:
                m = n_phi - 1
            else:
                m = n_phi

            for i2 in range(m): 
                # inital p coordinates corrected, converted to Cartesian
                p_init = np.array([rho_p[i1]*np.cos(phi_p[i2]),
                                   rho_p[i1]*np.sin(phi_p[i2]),
                                   0]) + np.array(self._p_init)
                p_init = p_init.tolist()

                # inital k coordinates
                k_init = self._k_init

                ray_list.append(Ray(p_init, k_init))

            self._n_tot += m
            n_phi += self._n

        return ray_list

    def propagate_via_elements(self, element_list):
        """Propagate each ray in the ray bundle through each of the optical
           element

        A list of ray positions are generated by obtaining the successive
        intercept between each of the optical element and the ray. The ray
        positions are represented by a list of Cartesian coordinates in 3D

        Arg:
            element_list -- a list of objects representing the optical
                            elements; each object has SphericalRefraction() as
                            its instance

        Return:
            ray_list -- a list of objects represent the rays in the ray bundle
                        with the position coordinates of each ray
        """

        if isinstance(element_list, list) is False:
            raise TypeError('element_list has to be a list of optical element '
                            + 'objects, e.g. [element] or [element1, element2]'
                            )

        ray_list = self.generate_ray_bundle()

        for ray in ray_list:
            for element in element_list:
                element.propagate_ray(ray)

        return ray_list

    def radius(self):
        """Return the radius of the ray bundle"""
        return self._radius

    def p_init(self):
        """Return the initial position coordinate of the ray bundle"""
        return self._p_init

    def k_init(self):
        """Return the initial direction coordinate of the ray bundle"""
        return self._k_init

    def n_tot(self):
        """Return the total number of rays in the ray bundle"""
        return self._n_tot
